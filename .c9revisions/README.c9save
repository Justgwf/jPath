{"ts":1351866466097,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"Can't get deeper than jPath does\n================================\nWell folks, JPath came about the same time I got pissed off at heavily nested JSON objects. \nIt was both lengthy, unreliable and unreadable when you had to write a whole line of \"IF\" checks just to get data\nmember nested 4 levels deep inside a JSON object. JPath is a traverse tool that allows XPATH-like navigation within a\nJSON structure and a little more. JPath also uses pattern syntax more familiar to JavaScript developers in the sense \nthat instead of \"/\" to navigate nodes I would use \".\" (dot) notation.\n\nHow does it work?\n=================\njPath is basically a recursive traverser that evaluates an expression you provide and finds each piece of data you\nspecify one step (recursion) at a time.\n\nDoes it support conditions?\n===========================\nJust like XPATH, it does support conditional filtering, where you basically specify what nodes you want to retrieve\nbased on certain condition. Conditional queries work by comparing data members to value you provide inside your\nexpression (it does not do comparing between data members). So for example if you have an array of objects and you want\nto get only those objects where member foo = 1, you would write \"obj[foo == 1]\", more examples later. It supports a\nwide range of evaluations here is the list:\n\n\"==\" | \"=\" - compares data member for equality\n\"!=\" - compares data member inequality\n\"<\" - less than\n\">\" - greater than\n\"<=\" - less or equal\n\">=\" - greater or equal\n\"~=\" - equal ignoring case\n\"^=\" - starts with\n\"$=\" - ends with\n\"*=\" - contains a string anywhere inside\n\"?\" - allows you to pass a custom evaluation function\nDuring the comparing stage, all values are type matched (coerced) to the types of values you're comparing against. \nWhat this means is that you always compare numbers against numbers and not strings, and same goes for every other data\ntype.\n\nIf your value contains a space, you can enclose your value in single quotes. (i.e. [foo == 'hello world']) Normally you\ndon't have to do that.\n\nWhat else it can do?\n====================\nOne thing to note is that there is a special \"*\" selector that references an object itself, so you may use it lets say\nagainst an array of objects (i.e. *[ foo == bah] - will return rows where member foo has value bah). You can also have\n\"deep\" value comparing (i.e. obj[ foo.bah == \"wow\"] ). Now that you can do deep value comparing, you can also check for\nnative properties such as \"length\" (i.e. obj( [ name.length > 3 ]) ).\n\nAPI\n===\nClasses:\n========\nJPath\n- constructor( json ) - initializes JPath instance\n- data - local copy of json object you passed in during init.\n- selection - cached result of the selection\n- from( json ) - this method allows you to change json source\n- first() - returns the first result value\n- last() - returns the last result value\n- eq( index ) - returns result value by index\n- select( pattern [, custom_compare_function ]) - performs recursive search\n- and( pattern ) - this method allows combining of multiple search results.\n- val() - <Array> returns the final value of selection\n\nMethods\n=======\nselect( json, expression [,cust_compare_fn] ) - performs a traversal and returns you an instance of JPath object\nfilter( json, expression [,cust_compare_fn] ) - performs a traversal and returns a value\n\nHow to's\n========\n1. Using Custom compare logic\n\njPath.filter( JSON, \"foo[bar ? test]\", function(left, right) {\n\t//left - is the value of the data member bar inside foo\n    //right - woudl be equal to \"test\"\n    \n\treturn left + \"blah\" == right; //Cusom validation\n});\n\n2. Joining multiple filtering results\n\njPath.select( JSON, \"foo[bar == 1]\").and( \"foo2[bar == 2]\").val(); //This example adds to the selection a different pattern evaluation\n\nExample above could also be written like so:\n\njPath.select( JSON, \"foo[bar == 1 && bar == 2]\").val();\n\nIf we want to combine results from different JSON objects, than we would do something like so:\n\njPath.select( JSON, \"foo[bar == 1]\").from(JSON2).and( \"foo2[bar == 2]\").val(); //from() sets a different source of data"]],"start1":0,"start2":0,"length1":0,"length2":4089}]],"length":4089}
{"contributors":[],"silentsave":false,"ts":1351866983678,"patch":[[{"diffs":[[0,"t source of data"],[1,"\n\n3. Accessing array elements by index\n\nEx. jPath.select({myArray:[1,2,3,4,5]}, \"myArray(0)\");"]],"start1":4073,"start2":4073,"length1":16,"length2":110}]],"length":4183,"saved":false}
{"ts":1351866988748,"patch":[[{"diffs":[[0,"ay(0)\");"],[1,"\n"]],"start1":4175,"start2":4175,"length1":8,"length2":9}]],"length":4184,"saved":false}
